'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var core = require('@theme-ui/core');
var css = require('@theme-ui/css');
var react = require('@emotion/react');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

var toVarName = function toVarName(key) {
  return "--theme-ui-" + key.replace('-__default', '');
};

var toVarValue = function toVarValue(key) {
  return "var(" + toVarName(key) + ")";
};

var join = function join() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.filter(Boolean).join('-');
};

var reservedKeys = new Set(['useCustomProperties', 'initialColorModeName', 'printColorModeName', 'initialColorMode', 'useLocalStorage', 'config']); // convert theme values to custom properties

var toCustomProperties = function toCustomProperties(obj, parent) {
  var next = Array.isArray(obj) ? [] : {};

  for (var key in obj) {
    var value = obj[key];
    var name = join(parent, key);

    if (value && typeof value === 'object') {
      next[key] = toCustomProperties(value, name);
      continue;
    }

    if (reservedKeys.has(key)) {
      next[key] = value;
      continue;
    }

    next[key] = toVarValue(name);
  }

  return next;
};
/**
 * @internal
 * Recursively transforms an object into CSS variables excluding "modes" key.
 */

var __objectToVars = function __objectToVars(parent, obj) {
  var vars = {};

  for (var key in obj) {
    if (key === 'modes') continue;
    var name = join(parent, key);
    var value = obj[key];

    if (value && typeof value === 'object') {
      vars = _extends({}, vars, __objectToVars(name, value));
    } else {
      vars[toVarName(name)] = value;
    }
  }

  return vars;
};
/**
 * @internal
 * Creates root styles for color modes.
 * - Transforms color scale into CSS variables.
 * - Sets background and text color.
 */

var __createColorStyles = function __createColorStyles(theme) {
  if (theme === void 0) {
    theme = {};
  }

  var _ref = theme.config || theme || {},
      useCustomProperties = _ref.useCustomProperties,
      initialColorModeName = _ref.initialColorModeName,
      printColorModeName = _ref.printColorModeName,
      useRootStyles = _ref.useRootStyles;

  var colors = theme.rawColors || theme.colors;
  if (!colors || useRootStyles === false) return {};

  if (useCustomProperties === false) {
    return css.css({
      color: 'text',
      bg: 'background'
    })(theme);
  }

  var modes = colors.modes || {};

  var styles = __createColorProperties(colors, modes);

  if (printColorModeName) {
    var printMode = modes[printColorModeName];
    if (!printMode && printColorModeName === initialColorModeName) printMode = colors;

    if (printMode) {
      styles['@media print'] = __objectToVars('colors', printMode);
    } else {
      console.error("Theme UI `printColorModeName` was not found in colors scale", {
        colors: colors,
        printColorModeName: printColorModeName
      });
    }
  }

  var colorToVarValue = function colorToVarValue(color) {
    return toVarValue("colors-" + color);
  };

  return css.css(_extends({}, styles, {
    color: colorToVarValue('text'),
    bg: colorToVarValue('background')
  }))(theme);
};
/**
 * @internal
 * Returns an object with colors turned into Custom CSS Properties and
 * .theme-ui-<colormode> classes used for no-flash serverside rendering.
 */

function __createColorProperties(colors, modes) {
  var styles = __objectToVars('colors', colors);

  Object.keys(modes).forEach(function (mode) {
    var className = ".theme-ui-" + mode;
    var key = "&" + className + ", " + className + " &";
    styles[key] = __objectToVars('colors', modes[mode]);
  });
  return styles;
}

var STORAGE_KEY = 'theme-ui-color-mode';
var DARK_QUERY = '(prefers-color-scheme: dark)';
var LIGHT_QUERY = '(prefers-color-scheme: light)';
var storage = {
  get: function get() {
    try {
      return window.localStorage.getItem(STORAGE_KEY);
    } catch (err) {
      console.warn('localStorage is disabled and color mode might not work as expected.', 'Please check your Site Settings.', err);
    }
  },
  set: function set(value) {
    try {
      window.localStorage.setItem(STORAGE_KEY, value);
    } catch (err) {
      console.warn('localStorage is disabled and color mode might not work as expected.', 'Please check your Site Settings.', err);
    }
  }
};

var getPreferredColorScheme = function getPreferredColorScheme() {
  if (typeof window !== 'undefined' && window.matchMedia) {
    if (window.matchMedia(DARK_QUERY).matches) {
      return 'dark';
    }

    if (window.matchMedia(LIGHT_QUERY).matches) {
      return 'light';
    }
  }

  return null;
};

var useClientsideEffect = typeof window === 'undefined' ? function () {} : React.useLayoutEffect;

var TopLevelColorModeProvider = function TopLevelColorModeProvider(_ref) {
  var outerCtx = _ref.outerCtx,
      children = _ref.children;
  var outerTheme = outerCtx.theme || {};

  var _ref2 = outerTheme.config || outerTheme,
      initialColorModeName = _ref2.initialColorModeName,
      useColorSchemeMediaQuery = _ref2.useColorSchemeMediaQuery,
      useLocalStorage = _ref2.useLocalStorage;

  var _useState = React.useState(function () {
    var preferredMode = useColorSchemeMediaQuery !== false && getPreferredColorScheme();
    return preferredMode || initialColorModeName;
  }),
      colorMode = _useState[0],
      setColorMode = _useState[1]; // on first render, we read the color mode from localStorage and
  // clear the class on document element body


  useClientsideEffect(function () {
    var stored = useLocalStorage !== false && storage.get();

    if (typeof document !== 'undefined') {
      document.documentElement.classList.remove('theme-ui-' + stored);
    }

    if (useColorSchemeMediaQuery !== 'system' && stored && stored !== colorMode) {
      colorMode = stored;
      setColorMode(stored);
    }
  }, []); // when mode changes, we save it to localStorage

  React.useEffect(function () {
    if (colorMode && useLocalStorage !== false) {
      storage.set(colorMode);
    }
  }, [colorMode, useLocalStorage]);
  var setPreferredColorScheme = React.useCallback(function () {
    var preferredColorScheme = getPreferredColorScheme();
    setColorMode(preferredColorScheme || initialColorModeName);
  }, [initialColorModeName]);
  React.useEffect(function () {
    if (useColorSchemeMediaQuery === 'system' && window.matchMedia) {
      // It doesn't matter if we add the listener only to the dark media query
      // Because in our callback function we'll check for both media queries (light and dark).
      var darkMQL = window.matchMedia(DARK_QUERY);

      if (typeof darkMQL.addEventListener === 'function') {
        darkMQL.addEventListener('change', setPreferredColorScheme);
      } else if (typeof darkMQL.addListener === 'function') {
        darkMQL.addListener(setPreferredColorScheme);
      }
    }

    return function () {
      if (useColorSchemeMediaQuery === 'system' && window.matchMedia) {
        var _darkMQL = window.matchMedia(DARK_QUERY);

        if (typeof _darkMQL.removeEventListener === 'function') {
          _darkMQL.removeEventListener('change', setPreferredColorScheme);
        } else if (typeof _darkMQL.removeListener === 'function') {
          _darkMQL.removeListener(setPreferredColorScheme);
        }
      }
    };
  }, [useColorSchemeMediaQuery, setPreferredColorScheme]);

  var newTheme = useThemeWithAppliedColorMode({
    colorMode: colorMode,
    outerTheme: outerTheme
  });

  var newCtx = _extends({}, outerCtx, {
    theme: newTheme,
    colorMode: colorMode,
    setColorMode: setColorMode
  });

  return /*#__PURE__*/React__default["default"].createElement(core.__ThemeUIInternalBaseThemeProvider, {
    context: newCtx
  }, /*#__PURE__*/React__default["default"].createElement(GlobalColorStyles, {
    theme: newTheme
  }), children);
};

function useColorMode() {
  var _useThemeUI = core.useThemeUI(),
      colorMode = _useThemeUI.colorMode,
      setColorMode = _useThemeUI.setColorMode;

  if (typeof setColorMode !== 'function') {
    throw new Error("[useColorMode] requires the ColorModeProvider component");
  } // We're allowing the user to specify a narrower type for its color mode name.


  return [colorMode, setColorMode];
}

var omitModes = function omitModes(colors) {
  var res = _extends({}, colors);

  delete res.modes;
  return res;
};

function copyRawColors(colors, outerThemeRawColors) {
  for (var _i = 0, _Object$entries = Object.entries(colors); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i],
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    if (typeof value === 'string' && !value.startsWith('var(')) {
      outerThemeRawColors[key] = value;
    } else if (typeof value === 'object') {
      var newValue = _extends({}, outerThemeRawColors[key]);

      copyRawColors(value, newValue);
      outerThemeRawColors[key] = newValue;
    }
  }
}

function useThemeWithAppliedColorMode(_ref3) {
  var outerTheme = _ref3.outerTheme,
      colorMode = _ref3.colorMode;
  var theme = React.useMemo(function () {
    var res = _extends({}, outerTheme);

    var modes = css.get(res, 'colors.modes', {});
    var currentColorMode = css.get(modes, colorMode, {});

    if (colorMode) {
      res.colors = _extends({}, res.colors, currentColorMode);
    }

    var _ref4 = outerTheme.config || outerTheme,
        useCustomProperties = _ref4.useCustomProperties,
        _ref4$initialColorMod = _ref4.initialColorModeName,
        initialColorModeName = _ref4$initialColorMod === void 0 ? '__default' : _ref4$initialColorMod;

    var outerThemeRawColors = outerTheme.rawColors || outerTheme.colors || {};

    if (useCustomProperties !== false) {
      var alreadyHasRawColors = res.rawColors != null;
      var colors = res.colors || {};

      if (alreadyHasRawColors) {
        outerThemeRawColors = _extends({}, outerThemeRawColors);
        copyRawColors(colors, outerThemeRawColors);

        if (outerThemeRawColors.modes) {
          outerThemeRawColors.modes[initialColorModeName] = omitModes(outerThemeRawColors);
        }

        res.rawColors = outerThemeRawColors;
      } else {
        if (!('modes' in outerThemeRawColors)) {
          res.rawColors = colors;
        } else {
          var _extends2;

          var _modes = _extends((_extends2 = {}, _extends2[initialColorModeName] = omitModes(outerThemeRawColors), _extends2), outerThemeRawColors.modes);

          res.rawColors = _extends({}, colors, {
            modes: _modes
          });
          /* modes doesn't match index signature by design */
        }
      }

      res.colors = toCustomProperties(omitModes(outerThemeRawColors), 'colors');
    }

    return res;
  }, [colorMode, outerTheme]);
  return theme;
}

function GlobalColorStyles(_ref5) {
  var theme = _ref5.theme;
  return core.jsx(react.Global, {
    styles: function styles() {
      return {
        html: __createColorStyles(theme)
      };
    }
  });
}

function NestedColorModeProvider(_ref6) {
  var _newTheme$config2;

  var outerCtx = _ref6.outerCtx,
      children = _ref6.children;
  var newTheme = useThemeWithAppliedColorMode({
    outerTheme: outerCtx.theme,
    colorMode: outerCtx.colorMode
  }); // Nested theme providers need to be rerendered after hydration for the correct
  // color mode to apply.

  var _useState2 = React.useState( // Note: we could also check some "ssr-enabled" flag as an optimization for
  // SPAs, as deeply nested theme providers will also pay a performance penalty
  // for this SSR bug fix
  function () {
    var _newTheme$config;

    return ((_newTheme$config = newTheme.config) == null ? void 0 : _newTheme$config.useLocalStorage) !== false;
  }),
      needsRerender = _useState2[0],
      setNeedsRerender = _useState2[1];

  useClientsideEffect(function () {
    return void setNeedsRerender(false);
  }, []);
  var themeColors = newTheme.rawColors || newTheme.colors;
  var useCustomProperties = (_newTheme$config2 = newTheme.config) == null ? void 0 : _newTheme$config2.useCustomProperties;
  var colorVars = React.useMemo(function () {
    if (useCustomProperties === false) {
      return {};
    }

    var colors = themeColors || {};
    return css.css(__createColorProperties(colors, colors.modes || {}))(newTheme);
  }, [newTheme, themeColors, useCustomProperties]);
  return /*#__PURE__*/React__default["default"].createElement(core.__ThemeUIInternalBaseThemeProvider, {
    context: _extends({}, outerCtx, {
      theme: newTheme
    })
  }, core.jsx('div', {
    'data-themeui-nested-provider': true,
    // the key here ensures that children will be rerendered after color
    // mode is read from localStorage
    key: Number(needsRerender),
    suppressHydrationWarning: true,
    css: colorVars,
    children: children
  }));
}

var ColorModeProvider = function ColorModeProvider(_ref7) {
  var children = _ref7.children;
  var outerCtx = core.useThemeUI();
  var isTopLevelColorModeProvider = typeof outerCtx.setColorMode !== 'function';
  return isTopLevelColorModeProvider ? /*#__PURE__*/React__default["default"].createElement(TopLevelColorModeProvider, {
    outerCtx: outerCtx
  }, children) : /*#__PURE__*/React__default["default"].createElement(NestedColorModeProvider, {
    outerCtx: outerCtx
  }, children);
};
var noflash = "(function() { try {\n  var mode = localStorage.getItem('theme-ui-color-mode');\n  if (!mode) return\n  document.documentElement.classList.add('theme-ui-' + mode);\n} catch (e) {} })();";
var InitializeColorMode = function InitializeColorMode() {
  return core.jsx('script', {
    key: 'theme-ui-no-flash',
    dangerouslySetInnerHTML: {
      __html: noflash
    }
  });
};

exports.ColorModeProvider = ColorModeProvider;
exports.InitializeColorMode = InitializeColorMode;
exports.useColorMode = useColorMode;
